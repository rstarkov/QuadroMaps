using System.Text;

namespace QuadroMaps.Core;

public sealed class BinaryWriter2 : BinaryWriter
{
    public BinaryWriter2(Stream stream) : base(stream) { }
    public long Position { get { return OutStream.Position; } set { OutStream.Position = value; } }
    public long Length => OutStream.Length;
    public override Stream BaseStream => OutStream; // we don't do buffered writes, so no need to flush the stream like the base implementation getter does
    public Action<BinaryWriter2> BeforeDispose = null;
    protected override void Dispose(bool disposing)
    {
        BeforeDispose?.Invoke(this);
        base.Dispose(disposing);
    }
}

public static class ExtensionMethods
{
    public static void Write7BitEncodedSignedInt(this BinaryWriter2 bw, int value)
    {
        // from RT.Util WriteInt32Optim
        while (value < -64 || value > 63)
        {
            bw.Write((byte)(value | 128));
            value >>= 7;
        }
        bw.Write((byte)(value & 127));
    }

    public static void Write7BitEncodedSignedInt64(this BinaryWriter2 bw, long value)
    {
        // from RT.Util WriteInt64Optim
        while (value < -64 || value > 63)
        {
            bw.Write((byte)(value | 128));
            value >>= 7;
        }
        bw.Write((byte)(value & 127));
    }

    public static long Read7BitEncodedSignedInt64(this BinaryReader br)
    {
        // from RT.Util ReadInt64Optim
        byte b;
        int shifts = 0;
        long res = 0;
        do
        {
            b = br.ReadByte();
            res |= ((long)(b & 127) << shifts);
            shifts += 7;
        } while (b > 127);
        // Sign-extend
        if (shifts >= 64) // can only be 63 or 70
            return res;
        shifts = 64 - shifts;
        return (res << shifts) >> shifts;
    }

    /// <summary>
    ///     Escapes all characters in this string which cannot form part of a valid filename on at least one supported
    ///     filesystem. The escaping is fully reversible (via <see cref="UnescapeFilename"/>), but does not
    ///     treat characters at specific positions differently (e.g. the "." at the end of the name is not escaped, even
    ///     though it will disappear on a Win32 system).</summary>
    public static string EscapeFilename(this string input, bool includeNonAscii = false)
    {
        // from RT.Util FilenameCharactersEscape
        if (input == null)
            throw new ArgumentNullException(nameof(input));

        var result = new StringBuilder(input.Length + input.Length / 2);
        foreach (char c in input)
        {
            var escape = false;
            switch (c)
            {
                case '\\':
                case '/':
                case '|':
                case ':':
                case '?':
                case '*':
                case '"':
                case '<':
                case '>':
                case '{':
                case '}':
                case (char)0x7F:
                    escape = true;
                    break;
            }
            if (c <= 0x1F || (c >= 128 && includeNonAscii))
                escape = true;
            if (escape)
            {
                result.Append('{');
                foreach (var bt in Encoding.UTF8.GetBytes(c.ToString()))
                    result.AppendFormat("{0:x2}", bt);
                result.Append('}');
            }
            else
                result.Append(c);
        }
        return result.ToString();
    }

    /// <summary>
    ///     Reverses the transformation done by <see cref="EscapeFilename"/>. Will also work on
    ///     filenames that cannot have been generated by the above escape procedure; any "invalid" escapes will be
    ///     preserved as-is.</summary>
    public static string UnescapeFilename(this string input)
    {
        // from RT.Util FilenameCharactersUnescape
        if (input == null)
            throw new ArgumentNullException(nameof(input));

        var result = new StringBuilder(input.Length);
        byte[] decode = new byte[4];

        int offset = 0;
        while (offset < input.Length)
        {
            if (input[offset] == '{')
            {
                int decodeCount = 0;
                int startOffset = offset; // set to -1 if decoded successfully
                offset++;
                while (offset < input.Length)
                {
                    char c = char.ToUpperInvariant(input[offset]);
                    if (c == '}')
                    {
                        offset++;
                        if (decodeCount > 0)
                        {
                            try
                            {
                                result.Append(Encoding.UTF8.GetString(decode, 0, decodeCount));
                                startOffset = -1; // successfully decoded this escape
                            }
                            catch (ArgumentException) { } // invalid escape
                        }
                        break;
                    }
                    else if (c >= '0' && c <= '9' || c >= 'A' && c <= 'F')
                    {
                        offset++;
                        if (offset >= input.Length || decodeCount == 4)
                            break; // input ended abruptly or the escape is now too long to be valid
                        char c2 = char.ToUpperInvariant(input[offset]);
                        if (c2 >= '0' && c2 <= '9' || c2 >= 'A' && c2 <= 'F')
                        {
                            offset++;
                            decode[decodeCount] = (byte)((c < 'A' ? c - '0' : c - '7') * 16 | (c2 < 'A' ? c2 - '0' : c2 - '7'));
                            decodeCount++;
                        }
                        else
                            break; // invalid second char
                    }
                    else
                    {
                        // invalid char encountered
                        break;
                    }
                }
                if (startOffset != -1)
                    result.Append(input, startOffset, offset - startOffset);
            }
            else
            {
                result.Append(input[offset]);
                offset++;
            }
        }
        return result.ToString();
    }
}
